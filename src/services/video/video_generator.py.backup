#!/usr/bin/env python3
"""Echo Brain Video Generation Service"""

import asyncio
import json
import logging
import os
import time
import uuid
import subprocess
import aiohttp
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from pydantic import BaseModel

logger = logging.getLogger(__name__)

COMFYUI_URL = "http://127.0.0.1:8188"
OUTPUT_DIR = Path("***REMOVED***/AI_Generated")
TEMP_DIR = Path("/tmp/echo_video_gen")

class VideoGenerationRequest(BaseModel):
    prompt: str
    project_id: Optional[str] = None
    character_name: Optional[str] = None
    duration: int = 5
    resolution: str = "1024x1024"
    style: str = "photorealistic anime"
    auto_fix_errors: bool = True

class EchoVideoGenerator:
    def __init__(self):
        self.client_id = str(uuid.uuid4())
        self.base_url = COMFYUI_URL
        self.max_retry_attempts = 3
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        TEMP_DIR.mkdir(parents=True, exist_ok=True)

    async def generate_video(self, request: VideoGenerationRequest) -> Dict:
        try:
            logger.info(f"Starting video generation for: {request.prompt}")
            start_time = time.time()
            
            await self._check_comfyui_health()
            workflow = await self._create_video_workflow(request)
            prompt_id = await self._submit_workflow(workflow)
            result = await self._wait_for_completion(prompt_id)
            video_path = await self._process_results(result, request)
            
            total_time = time.time() - start_time
            
            return {
                "success": True,
                "video_path": str(video_path),
                "prompt": request.prompt,
                "duration": request.duration,
                "generation_time": total_time,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Video generation failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "prompt": request.prompt,
                "timestamp": datetime.now().isoformat()
            }

    async def _check_comfyui_health(self) -> bool:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.base_url}/system_stats", timeout=5) as response:
                    if response.status == 200:
                        logger.info("ComfyUI health check passed")
                        return True
        except Exception as e:
            logger.error(f"ComfyUI health check failed: {e}")
            raise Exception("ComfyUI service is not available")

    async def _create_video_workflow(self, request: VideoGenerationRequest) -> Dict:
        enhanced_prompt = f"{request.prompt}, {request.style}, cinematic quality, high detail, masterpiece"
        
        workflow = {
            "3": {
                "inputs": {
                    "seed": 42,
                    "steps": 20,
                    "cfg": 8,
                    "sampler_name": "euler",
                    "scheduler": "normal",
                    "denoise": 1,
                    "model": ["4", 0],
                    "positive": ["6", 0],
                    "negative": ["7", 0],
                    "latent_image": ["5", 0]
                },
                "class_type": "KSampler"
            },
            "4": {
                "inputs": {
                    "ckpt_name": "epicrealism_v5.safetensors"
                },
                "class_type": "CheckpointLoaderSimple"
            },
            "5": {
                "inputs": {
                    "width": 1024,
                    "height": 1024,
                    "batch_size": 1
                },
                "class_type": "EmptyLatentImage"
            },
            "6": {
                "inputs": {
                    "text": enhanced_prompt.strip(),
                    "clip": ["4", 1]
                },
                "class_type": "CLIPTextEncode"
            },
            "7": {
                "inputs": {
                    "text": "blurry, low quality, distorted, bad anatomy",
                    "clip": ["4", 1]
                },
                "class_type": "CLIPTextEncode"
            },
            "8": {
                "inputs": {
                    "samples": ["3", 0],
                    "vae": ["4", 2]
                },
                "class_type": "VAEDecode"
            },
            "9": {
                "inputs": {
                    "filename_prefix": f"echo_video_{int(time.time())}",
                    "images": ["8", 0]
                },
                "class_type": "SaveImage"
            }
        }
        
        logger.info("Created video generation workflow")
        return workflow

    async def _submit_workflow(self, workflow: Dict) -> str:
        try:
            async with aiohttp.ClientSession() as session:
                payload = {"prompt": workflow, "client_id": self.client_id}
                async with session.post(f"{self.base_url}/prompt", json=payload) as response:
                    if response.status == 200:
                        result = await response.json()
                        prompt_id = result["prompt_id"]
                        logger.info(f"Workflow submitted with prompt ID: {prompt_id}")
                        return prompt_id
                    else:
                        raise Exception(f"Failed to submit workflow: {response.status}")
        except Exception as e:
            logger.error(f"Failed to submit workflow: {e}")
            raise

    async def _wait_for_completion(self, prompt_id: str) -> Dict:
        logger.info(f"Waiting for generation completion: {prompt_id}")
        
        for attempt in range(60):
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"{self.base_url}/history/{prompt_id}") as response:
                        if response.status == 200:
                            history = await response.json()
                            if prompt_id in history:
                                result = history[prompt_id]
                                if "outputs" in result:
                                    logger.info("Generation completed successfully")
                                    return result
                            
                await asyncio.sleep(5)
                
            except Exception as e:
                logger.warning(f"Error checking completion status: {e}")
                await asyncio.sleep(5)
        
        raise Exception("Generation timed out after 5 minutes")

    async def _process_results(self, result: Dict, request: VideoGenerationRequest) -> Path:
        try:
            outputs = result.get("outputs", {})
            image_files = []
            
            for node_id, output in outputs.items():
                if "images" in output:
                    for image_info in output["images"]:
                        filename = image_info["filename"]
                        subfolder = image_info.get("subfolder", "")
                        source_path = Path(f"***REMOVED***/ComfyUI-Production/output/{subfolder}/{filename}")
                        if source_path.exists():
                            image_files.append(source_path)
            
            if not image_files:
                raise Exception("No images generated")
            
            first_image = image_files[0]
            timestamp = int(time.time())
            clean_prompt = request.prompt[:20].replace(" ", "_").replace("/", "_")
            video_filename = f"echo_video_{timestamp}_{clean_prompt}.png"
            video_path = OUTPUT_DIR / video_filename
            
            import shutil
            shutil.copy2(first_image, video_path)
            os.chmod(video_path, 0o644)
            
            logger.info(f"Video saved to: {video_path}")
            return video_path
            
        except Exception as e:
            logger.error(f"Failed to process results: {e}")
            raise
