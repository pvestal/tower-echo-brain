#!/usr/bin/env python3
"""
Autonomous Repair Executor
Executes actual repairs with DAILY digest email notifications and detailed logging
"""

import asyncio
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
from pathlib import Path
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import json

logger = logging.getLogger(__name__)

class RepairExecutor:
    """Executes autonomous repairs with notifications and logging"""

    def __init__(self):
        self.repair_log_path = Path("/opt/tower-echo-brain/logs/autonomous_repairs.log")
        self.repair_history: List[Dict[str, Any]] = []
        self.pending_repairs: List[Dict[str, Any]] = []  # Queue for daily digest
        self.smtp_config = {
            'server': 'smtp.gmail.com',
            'port': 587,
            'from_email': 'patrick.vestal.digital@gmail.com',
            'to_email': 'patrick.vestal@gmail.com'
        }

        # Load Gmail app password from vault or environment
        self.app_password = self._load_smtp_credentials()

    def _load_smtp_credentials(self) -> Optional[str]:
        """Load SMTP credentials from Vault"""
        try:
            import hvac
            import os
            client = hvac.Client(url='http://127.0.0.1:8200', token=os.environ.get('VAULT_TOKEN'))
            # Try to get from vault
            response = client.secrets.kv.v2.read_secret_version(path='tower/gmail')
            return response['data']['data'].get('app_password')
        except Exception as e:
            logger.warning(f"Could not load SMTP credentials from Vault: {e}")
            return None

    async def execute_repair(self, repair_type: str, target: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Execute a repair action"""

        logger.info(f"üîß Starting repair: {repair_type} for {target}")

        result = {
            'success': False,
            'repair_type': repair_type,
            'target': target,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': [],
            'error': None
        }

        try:
            # Execute repair based on type
            if repair_type == 'service_restart':
                result = await self._repair_service_restart(target, issue, **kwargs)
            elif repair_type == 'systemd_config_fix':
                result = await self._repair_systemd_config(target, issue, **kwargs)
            elif repair_type == 'disk_cleanup':
                result = await self._repair_disk_cleanup(target, issue, **kwargs)
            elif repair_type == 'process_kill':
                result = await self._repair_process_kill(target, issue, **kwargs)
            elif repair_type == 'log_rotation':
                result = await self._repair_log_rotation(target, issue, **kwargs)
            else:
                result['error'] = f"Unknown repair type: {repair_type}"

            # Log the repair
            await self._log_repair(result)

            # Queue for daily digest instead of sending immediately
            self.pending_repairs.append(result)
            logger.info(f"üìã Repair queued for daily digest ({len(self.pending_repairs)} pending)")

            # Store in history
            self.repair_history.append(result)

            return result

        except Exception as e:
            logger.error(f"‚ùå Repair failed: {e}")
            result['error'] = str(e)
            await self._log_repair(result)
            self.pending_repairs.append(result)  # Queue failed repairs too
            return result

    async def send_daily_digest(self) -> Dict[str, Any]:
        """Send daily digest email with all repairs from the last 24 hours"""
        
        if not self.pending_repairs:
            logger.info("üìß No repairs to report in daily digest")
            return {'sent': False, 'reason': 'no_repairs'}

        try:
            # Count successes and failures
            total = len(self.pending_repairs)
            successes = sum(1 for r in self.pending_repairs if r.get('success'))
            failures = total - successes

            # Create summary
            status_emoji = "‚úÖ" if failures == 0 else "‚ö†Ô∏è"
            subject = f"üîß Echo Daily Repair Report: {total} repairs ({successes} ‚úÖ, {failures} ‚ùå)"

            # Build repair list
            repair_entries = []
            for i, repair in enumerate(self.pending_repairs, 1):
                success = repair.get('success', False)
                repair_emoji = "‚úÖ" if success else "‚ùå"
                repair_type = repair.get('repair_type', 'unknown')
                target = repair.get('target', 'unknown')
                timestamp = repair.get('timestamp', 'unknown')
                actions = repair.get('actions_taken', [])
                error = repair.get('error')

                entry = f"""
{i}. {repair_emoji} {repair_type.upper()}
   Target: {target}
   Time: {timestamp}
   Actions: {', '.join(actions) if actions else 'None'}"""
                
                if error:
                    entry += f"\n   Error: {error}"
                
                repair_entries.append(entry)

            repair_text = '\n'.join(repair_entries)

            body = f"""Echo Brain Daily Autonomous Repair Report
==========================================

Period: Last 24 hours
Total Repairs: {total}
Successful: {successes} ‚úÖ
Failed: {failures} ‚ùå

REPAIR DETAILS:
{repair_text}

---
Full repair log: /opt/tower-echo-brain/logs/autonomous_repairs.log
This is a daily digest sent at 9:00 AM
"""

            # Send email
            await self._send_email(subject, body)
            
            # Clear pending repairs after sending
            repair_count = len(self.pending_repairs)
            self.pending_repairs.clear()
            
            logger.info(f"‚úÖ Daily digest sent with {repair_count} repairs")
            
            return {'sent': True, 'repairs_count': repair_count}

        except Exception as e:
            logger.error(f"Failed to send daily digest: {e}")
            return {'sent': False, 'error': str(e)}

    async def _repair_service_restart(self, service: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Restart a systemd service"""

        result = {
            'success': False,
            'repair_type': 'service_restart',
            'target': service,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': [],
            'error': None
        }

        try:
            # Check if service exists
            check_cmd = f"systemctl list-unit-files | grep {service}"
            proc = await asyncio.create_subprocess_shell(
                check_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            if proc.returncode != 0:
                result['error'] = f"Service {service} not found"
                return result

            result['actions_taken'].append(f"Verified service {service} exists")

            # Restart the service
            restart_cmd = f"sudo systemctl restart {service}"
            proc = await asyncio.create_subprocess_shell(
                restart_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            if proc.returncode == 0:
                result['actions_taken'].append(f"Successfully restarted {service}")
                result['success'] = True
            else:
                result['error'] = f"Failed to restart: {stderr.decode()}"

            # Wait a moment for service to start
            await asyncio.sleep(3)

            # Check status
            status_cmd = f"systemctl is-active {service}"
            proc = await asyncio.create_subprocess_shell(
                status_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            status = stdout.decode().strip()
            result['actions_taken'].append(f"Service status after restart: {status}")

            if status == "active":
                result['success'] = True

            return result

        except Exception as e:
            result['error'] = str(e)
            return result

    async def _repair_systemd_config(self, service: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Fix systemd service configuration - stub for now"""
        return {
            'success': False,
            'repair_type': 'systemd_config_fix',
            'target': service,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': ['Not yet implemented'],
            'error': 'systemd_config_fix not yet implemented - requires manual intervention'
        }

    async def _repair_disk_cleanup(self, target: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Clean up disk space - stub for now"""
        return {
            'success': False,
            'repair_type': 'disk_cleanup',
            'target': target,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': ['Not yet implemented'],
            'error': 'disk_cleanup not yet implemented - requires manual intervention'
        }

    async def _repair_process_kill(self, target: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Kill a stuck process"""

        result = {
            'success': False,
            'repair_type': 'process_kill',
            'target': target,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': [],
            'error': None
        }

        try:
            pid = kwargs.get('pid')
            if not pid:
                result['error'] = "No PID provided"
                return result

            # Try graceful kill first
            kill_cmd = f"kill {pid}"
            proc = await asyncio.create_subprocess_shell(
                kill_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await proc.communicate()
            result['actions_taken'].append(f"Sent SIGTERM to PID {pid}")

            # Wait a moment
            await asyncio.sleep(3)

            # Check if process is still running
            check_cmd = f"ps -p {pid}"
            proc = await asyncio.create_subprocess_shell(
                check_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            if proc.returncode != 0:
                # Process is gone
                result['actions_taken'].append(f"Process {pid} terminated successfully")
                result['success'] = True
            else:
                # Force kill
                force_kill_cmd = f"kill -9 {pid}"
                proc = await asyncio.create_subprocess_shell(
                    force_kill_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await proc.communicate()
                result['actions_taken'].append(f"Sent SIGKILL to PID {pid}")
                result['success'] = True

            return result

        except Exception as e:
            result['error'] = str(e)
            return result

    async def _repair_log_rotation(self, target: str, issue: str, **kwargs) -> Dict[str, Any]:
        """Rotate large log files - stub for now"""
        return {
            'success': False,
            'repair_type': 'log_rotation',
            'target': target,
            'issue': issue,
            'timestamp': datetime.now().isoformat(),
            'actions_taken': ['Not yet implemented'],
            'error': 'log_rotation not yet implemented - requires manual intervention'
        }

    async def _log_repair(self, result: Dict[str, Any]):
        """Log repair action to file"""

        try:
            log_entry = {
                'timestamp': result.get('timestamp'),
                'repair_type': result.get('repair_type'),
                'target': result.get('target'),
                'issue': result.get('issue'),
                'success': result.get('success'),
                'actions_taken': result.get('actions_taken'),
                'error': result.get('error')
            }

            # Ensure log directory exists
            self.repair_log_path.parent.mkdir(parents=True, exist_ok=True)

            # Append to log file
            with open(self.repair_log_path, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')

            repair_type = result.get('repair_type', 'unknown')
            target = result.get('target', 'unknown')
            logger.info(f"üìù Logged repair: {repair_type} for {target}")

        except Exception as e:
            logger.error(f"Failed to log repair: {e}")

    async def _send_email(self, subject: str, body: str):
        """Send email via Gmail SMTP"""

        try:
            # For now, log the email content
            logger.info(f"üìß Email Notification:\nSubject: {subject}\n{body}")

            # Try to send if credentials are available
            if self.app_password:
                msg = MIMEMultipart()
                msg['From'] = self.smtp_config['from_email']
                msg['To'] = self.smtp_config['to_email']
                msg['Subject'] = subject
                msg.attach(MIMEText(body, 'plain'))

                with smtplib.SMTP('localhost', 25) as server:
                    # Local Postfix relay - no auth needed
                    server.send_message(msg)

                logger.info("‚úÖ Email sent successfully")
            else:
                logger.warning("‚ö†Ô∏è SMTP credentials not configured - email logged only")

        except Exception as e:
            logger.error(f"Failed to send email: {e}")

# Global instance
repair_executor = RepairExecutor()
