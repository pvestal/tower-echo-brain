#!/usr/bin/env python3
"""
Input Processor - Modular component for handling all input sources
Supports chat inputs, API calls, autonomous triggers, and external data
"""

import json
import logging
import traceback
from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass, asdict
from enum import Enum

logger = logging.getLogger(__name__)

class InputType(Enum):
    CHAT_MESSAGE = "chat_message"
    API_REQUEST = "api_request"
    VOICE_INPUT = "voice_input"
    AUTONOMOUS_TRIGGER = "autonomous_trigger"
    EXTERNAL_DATA = "external_data"
    WEBHOOK = "webhook"
    SYSTEM_EVENT = "system_event"

@dataclass
class ProcessedInput:
    """Standardized input structure after processing"""
    input_type: InputType
    content: str
    context: Dict[str, Any]
    user_id: str
    conversation_id: str
    timestamp: datetime
    priority: int = 5  # 1-10, 10 = highest
    requires_auth: bool = False
    metadata: Dict[str, Any] = None
    raw_input: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        if self.raw_input is None:
            self.raw_input = {}

class InputProcessor:
    """
    Processes and validates input from various sources
    Provides standardized input format for downstream components
    """
    
    def __init__(self, config_manager, logger=None):
        self.config_manager = config_manager
        self.logger = logger or logging.getLogger(__name__)
        self.input_validators = self._setup_validators()
        self.input_transformers = self._setup_transformers()
        
    def _setup_validators(self) -> Dict[str, callable]:
        """Setup input validation functions"""
        return {
            InputType.CHAT_MESSAGE: self._validate_chat_message,
            InputType.API_REQUEST: self._validate_api_request,
            InputType.VOICE_INPUT: self._validate_voice_input,
            InputType.AUTONOMOUS_TRIGGER: self._validate_autonomous_trigger,
            InputType.EXTERNAL_DATA: self._validate_external_data,
            InputType.WEBHOOK: self._validate_webhook,
            InputType.SYSTEM_EVENT: self._validate_system_event,
        }
    
    def _setup_transformers(self) -> Dict[str, callable]:
        """Setup input transformation functions"""
        return {
            InputType.CHAT_MESSAGE: self._transform_chat_message,
            InputType.API_REQUEST: self._transform_api_request,
            InputType.VOICE_INPUT: self._transform_voice_input,
            InputType.AUTONOMOUS_TRIGGER: self._transform_autonomous_trigger,
            InputType.EXTERNAL_DATA: self._transform_external_data,
            InputType.WEBHOOK: self._transform_webhook,
            InputType.SYSTEM_EVENT: self._transform_system_event,
        }
    
    async def process(self, raw_input: Dict[str, Any], input_type: InputType) -> Optional[ProcessedInput]:
        """
        Main processing method for all input types
        Returns ProcessedInput object or None if processing fails
        """
        try:
            self.logger.info(f"Processing input of type: {input_type.value}")
            
            # Validate input
            if not self._validate_input(raw_input, input_type):
                self.logger.error(f"Input validation failed for type: {input_type.value}")
                return None
            
            # Transform input to standard format
            processed = await self._transform_input(raw_input, input_type)
            if not processed:
                self.logger.error(f"Input transformation failed for type: {input_type.value}")
                return None
            
            # Apply security filters
            processed = self._apply_security_filters(processed)
            
            # Add processing metadata
            processed.metadata.update({
                'processed_at': datetime.now().isoformat(),
                'processor_version': '2.0.0',
                'input_size_bytes': len(str(raw_input))
            })
            
            self.logger.info(f"Successfully processed input: {processed.conversation_id}")
            return processed
            
        except Exception as e:
            self.logger.error(f"Input processing error: {str(e)}")
            self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return None
    
    def _validate_input(self, raw_input: Dict[str, Any], input_type: InputType) -> bool:
        """Validate input using type-specific validator"""
        try:
            validator = self.input_validators.get(input_type)
            if not validator:
                self.logger.error(f"No validator found for input type: {input_type.value}")
                return False
            return validator(raw_input)
        except Exception as e:
            self.logger.error(f"Validation error: {str(e)}")
            return False
    
    async def _transform_input(self, raw_input: Dict[str, Any], input_type: InputType) -> Optional[ProcessedInput]:
        """Transform input using type-specific transformer"""
        try:
            transformer = self.input_transformers.get(input_type)
            if not transformer:
                self.logger.error(f"No transformer found for input type: {input_type.value}")
                return None
            return await transformer(raw_input)
        except Exception as e:
            self.logger.error(f"Transformation error: {str(e)}")
            return None
    
    def _apply_security_filters(self, processed: ProcessedInput) -> ProcessedInput:
        """Apply security filters to processed input"""
        try:
            # Remove sensitive information
            sensitive_keys = ['password', 'token', 'secret', 'key', 'auth']
            for key in list(processed.context.keys()):
                if any(sensitive in key.lower() for sensitive in sensitive_keys):
                    processed.context[key] = '[REDACTED]'
            
            # Sanitize content
            if processed.content:
                # Basic XSS prevention
                processed.content = processed.content.replace('<script', '&lt;script')
                processed.content = processed.content.replace('javascript:', '')
            
            return processed
            
        except Exception as e:
            self.logger.error(f"Security filter error: {str(e)}")
            return processed
    
    # Type-specific validators
    def _validate_chat_message(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['query', 'user_id']
        return all(field in raw_input for field in required_fields)
    
    def _validate_api_request(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['query', 'user_id']
        return all(field in raw_input for field in required_fields)
    
    def _validate_voice_input(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['audio_data', 'user_id']
        return all(field in raw_input for field in required_fields)
    
    def _validate_autonomous_trigger(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['trigger_type', 'trigger_data']
        return all(field in raw_input for field in required_fields)
    
    def _validate_external_data(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['data_source', 'data_content']
        return all(field in raw_input for field in required_fields)
    
    def _validate_webhook(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['webhook_source', 'payload']
        return all(field in raw_input for field in required_fields)
    
    def _validate_system_event(self, raw_input: Dict[str, Any]) -> bool:
        required_fields = ['event_type', 'event_data']
        return all(field in raw_input for field in required_fields)
    
    # Type-specific transformers
    async def _transform_chat_message(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.CHAT_MESSAGE,
            content=raw_input.get('query', ''),
            context=raw_input.get('context', {}),
            user_id=raw_input.get('user_id', 'anonymous'),
            conversation_id=raw_input.get('conversation_id', f"chat_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 5),
            requires_auth=raw_input.get('requires_auth', False),
            raw_input=raw_input
        )
    
    async def _transform_api_request(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.API_REQUEST,
            content=raw_input.get('query', ''),
            context=raw_input.get('context', {}),
            user_id=raw_input.get('user_id', 'api_user'),
            conversation_id=raw_input.get('conversation_id', f"api_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 7),
            requires_auth=raw_input.get('requires_auth', True),
            raw_input=raw_input
        )
    
    async def _transform_voice_input(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        # Voice input would need speech-to-text processing here
        content = raw_input.get('transcribed_text', '[Voice input - transcription needed]')
        return ProcessedInput(
            input_type=InputType.VOICE_INPUT,
            content=content,
            context={'audio_metadata': raw_input.get('audio_metadata', {})},
            user_id=raw_input.get('user_id', 'voice_user'),
            conversation_id=raw_input.get('conversation_id', f"voice_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 8),
            requires_auth=raw_input.get('requires_auth', True),
            raw_input=raw_input
        )
    
    async def _transform_autonomous_trigger(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.AUTONOMOUS_TRIGGER,
            content=f"Autonomous trigger: {raw_input.get('trigger_type', 'unknown')}",
            context=raw_input.get('trigger_data', {}),
            user_id='system',
            conversation_id=raw_input.get('conversation_id', f"auto_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 6),
            requires_auth=False,
            raw_input=raw_input
        )
    
    async def _transform_external_data(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.EXTERNAL_DATA,
            content=f"External data from: {raw_input.get('data_source', 'unknown')}",
            context={'data_content': raw_input.get('data_content', {})},
            user_id=raw_input.get('user_id', 'external_system'),
            conversation_id=raw_input.get('conversation_id', f"ext_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 4),
            requires_auth=raw_input.get('requires_auth', True),
            raw_input=raw_input
        )
    
    async def _transform_webhook(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.WEBHOOK,
            content=f"Webhook from: {raw_input.get('webhook_source', 'unknown')}",
            context={'payload': raw_input.get('payload', {})},
            user_id=raw_input.get('user_id', 'webhook_user'),
            conversation_id=raw_input.get('conversation_id', f"webhook_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 7),
            requires_auth=raw_input.get('requires_auth', True),
            raw_input=raw_input
        )
    
    async def _transform_system_event(self, raw_input: Dict[str, Any]) -> ProcessedInput:
        return ProcessedInput(
            input_type=InputType.SYSTEM_EVENT,
            content=f"System event: {raw_input.get('event_type', 'unknown')}",
            context=raw_input.get('event_data', {}),
            user_id='system',
            conversation_id=raw_input.get('conversation_id', f"sys_{datetime.now().timestamp()}"),
            timestamp=datetime.now(),
            priority=raw_input.get('priority', 9),
            requires_auth=False,
            raw_input=raw_input
        )

    def get_processing_stats(self) -> Dict[str, Any]:
        """Return processing statistics"""
        return {
            'supported_input_types': [t.value for t in InputType],
            'config_loaded': self.config_manager is not None,
            'validators_count': len(self.input_validators),
            'transformers_count': len(self.input_transformers),
        }

    @property
    def supported_input_types(self) -> List[str]:
        """Get list of supported input types"""
        return [input_type.value for input_type in InputType]

    async def process(self, raw_input: Dict[str, Any]) -> Dict[str, Any]:
        """Simplified process method for backward compatibility"""
        try:
            # Auto-detect input type from raw_input
            input_type_str = raw_input.get("type", "chat_message")
            try:
                input_type = InputType(input_type_str)
            except ValueError:
                input_type = InputType.CHAT_MESSAGE
            
            # Use the detailed process method
            processed = await self.process_detailed(raw_input, input_type)
            if processed:
                return {"status": "success", "data": asdict(processed)}
            else:
                return {"status": "error", "message": "Processing failed"}
        except Exception as e:
            self.logger.error(f"Process error: {str(e)}")
            return {"status": "error", "message": str(e)}

    async def process_detailed(self, raw_input: Dict[str, Any], input_type: InputType) -> Optional[ProcessedInput]:
        """Original detailed processing method (renamed)"""
        # This is the original process method content
        try:
            self.logger.info(f"Processing input of type: {input_type.value}")
            
            # Validate input
            if not self._validate_input(raw_input, input_type):
                self.logger.error(f"Input validation failed for type: {input_type.value}")
                return None
            
            # Transform input to standard format
            processed = await self._transform_input(raw_input, input_type)
            if not processed:
                self.logger.error(f"Input transformation failed for type: {input_type.value}")
                return None
            
            # Apply security filters
            processed = self._apply_security_filters(processed)
            
            # Add processing metadata
            processed.metadata.update({
                processed_at: datetime.now().isoformat(),
                processor_version: 2.0.0,
                input_size_bytes: len(str(raw_input))
            })
            
            self.logger.info(f"Successfully processed input: {processed.conversation_id}")
            return processed
            
        except Exception as e:
            self.logger.error(f"Input processing error: {str(e)}")
            self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return None
