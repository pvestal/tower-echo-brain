#!/usr/bin/env python3
"""
Configuration Manager - Centralized configuration management for Echo Brain
Handles environment variables, secrets, and dynamic configuration updates
"""

import os
import json
import logging
import traceback
import yaml
from typing import Any, Dict, List, Optional, Union
from pathlib import Path
from dataclasses import dataclass, asdict
from enum import Enum
import hashlib
from datetime import datetime

logger = logging.getLogger(__name__)

class ConfigSource(Enum):
    ENVIRONMENT = "environment"
    FILE = "file"
    VAULT = "vault"
    DATABASE = "database"
    RUNTIME = "runtime"

@dataclass
class ConfigItem:
    """Individual configuration item"""
    key: str
    value: Any
    source: ConfigSource
    is_secret: bool = False
    last_updated: datetime = None
    description: str = ""
    
    def __post_init__(self):
        if self.last_updated is None:
            self.last_updated = datetime.now()

class ConfigurationManager:
    """
    Centralized configuration management with multiple sources
    Supports environment variables, files, Vault, and runtime updates
    """
    
    def __init__(self, config_file_path: Optional[str] = None, logger=None):
        self.logger = logger or logging.getLogger(__name__)
        self.config_file_path = config_file_path or "/opt/tower-echo-brain/config/echo_config.yaml"
        self.config_items: Dict[str, ConfigItem] = {}
        self.watchers: Dict[str, List[callable]] = {}
        self._config_hash = ""
        
        # Initialize configuration
        self._load_default_config()
        self._load_environment_config()
        self._load_file_config()
        self._load_vault_config()
        
        # Calculate initial hash
        self._update_config_hash()
        
    def _load_default_config(self):
        """Load default configuration values"""
        defaults = {
            # Echo Brain Core Settings
            "echo.intelligence_levels": ["1b", "7b", "16b", "70b"],
            "echo.default_model": "qwen2.5-coder:7b",
            "echo.max_response_length": 4000,
            "echo.conversation_timeout": 3600,
            "echo.max_concurrent_requests": 10,
            
            # API Configuration
            "api.host": "0.0.0.0",
            "api.port": 8309,
            "api.workers": 4,
            "api.timeout": 30,
            "api.cors_enabled": True,
            
            # Database Configuration
            "database.host": "localhost",
            "database.port": 5432,
            "database.name": "echo_brain",
            "database.pool_size": 10,
            "database.max_overflow": 20,
            
            # Logging Configuration
            "logging.level": "INFO",
            "logging.format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            "logging.file_path": "/opt/tower-echo-brain/logs/echo.log",
            "logging.max_file_size": "10MB",
            "logging.backup_count": 5,
            
            # Security Configuration
            "security.require_auth": True,
            "security.session_timeout": 3600,
            "security.max_login_attempts": 5,
            "security.cors_origins": ["https://***REMOVED***", "http://localhost:3000"],
            
            # Personal Data Integration
            "personal_data.google_suite_enabled": True,
            "personal_data.apple_music_enabled": True,
            "personal_data.financial_data_enabled": True,
            "personal_data.git_integration_enabled": True,
            "personal_data.cache_timeout": 300,
            
            # Voice Configuration
            "voice.enabled": True,
            "voice.synthesis_engine": "espeak",
            "voice.default_voice": "en",
            "voice.speed": 1.0,
            "voice.pitch": 1.0,
            
            # Model Configuration
            "models.ollama_url": "http://localhost:11434",
            "models.escalation_threshold": 0.7,
            "models.confidence_threshold": 0.5,
            "models.fallback_model": "qwen2.5-coder:1.5b",
            
            # File Paths
            "paths.base_dir": "/opt/tower-echo-brain",
            "paths.logs_dir": "/opt/tower-echo-brain/logs",
            "paths.data_dir": "/opt/tower-echo-brain/data",
            "paths.vault_dir": "/opt/tower-echo-brain/vault_data",
            
            # Feature Flags
            "features.board_of_directors": True,
            "features.autonomous_learning": True,
            "features.agent_development": True,
            "features.quality_monitoring": True,
            "features.veteran_support": True,
            "features.telegram_integration": True,
        }
        
        for key, value in defaults.items():
            self.config_items[key] = ConfigItem(
                key=key,
                value=value,
                source=ConfigSource.RUNTIME,
                description=f"Default configuration for {key}"
            )
    
    def _load_environment_config(self):
        """Load configuration from environment variables"""
        try:
            env_prefix = "ECHO_"
            for key, value in os.environ.items():
                if key.startswith(env_prefix):
                    config_key = key[len(env_prefix):].lower().replace("_", ".")
                    
                    # Try to parse as JSON first, then as string
                    try:
                        parsed_value = json.loads(value)
                    except (json.JSONDecodeError, TypeError):
                        parsed_value = value
                    
                    # Determine if it's a secret
                    is_secret = any(secret_word in key.lower() for secret_word in ["password", "secret", "key", "token"])
                    
                    self.config_items[config_key] = ConfigItem(
                        key=config_key,
                        value=parsed_value,
                        source=ConfigSource.ENVIRONMENT,
                        is_secret=is_secret,
                        description=f"Environment variable: {key}"
                    )
            
            self.logger.info(f"Loaded {len([k for k, v in self.config_items.items() if v.source == ConfigSource.ENVIRONMENT])} environment variables")
            
        except Exception as e:
            self.logger.error(f"Error loading environment config: {str(e)}")
    
    def _load_file_config(self):
        """Load configuration from YAML/JSON file"""
        try:
            if not os.path.exists(self.config_file_path):
                self.logger.info(f"Config file not found: {self.config_file_path}, using defaults")
                return
            
            with open(self.config_file_path, 'r') as f:
                if self.config_file_path.endswith('.yaml') or self.config_file_path.endswith('.yml'):
                    file_config = yaml.safe_load(f)
                else:
                    file_config = json.load(f)
            
            # Flatten nested configuration
            flat_config = self._flatten_dict(file_config)
            
            for key, value in flat_config.items():
                self.config_items[key] = ConfigItem(
                    key=key,
                    value=value,
                    source=ConfigSource.FILE,
                    description=f"File configuration: {self.config_file_path}"
                )
            
            self.logger.info(f"Loaded {len(flat_config)} items from config file: {self.config_file_path}")
            
        except Exception as e:
            self.logger.error(f"Error loading file config: {str(e)}")
    
    def _load_vault_config(self):
        """Load configuration from HashiCorp Vault"""
        try:
            # This would integrate with the existing vault_client.py
            # For now, just log that vault integration is available
            self.logger.info("Vault configuration integration available")
            
        except Exception as e:
            self.logger.error(f"Error loading vault config: {str(e)}")
    
    def _flatten_dict(self, d: Dict, parent_key: str = '', sep: str = '.') -> Dict:
        """Flatten nested dictionary with dot notation"""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self._flatten_dict(v, new_key, sep=sep).items())
            else:
                items.append((new_key, v))
        return dict(items)
    
    def _update_config_hash(self):
        """Update configuration hash for change detection"""
        try:
            config_str = json.dumps(
                {k: v.value for k, v in self.config_items.items() if not v.is_secret},
                sort_keys=True
            )
            self._config_hash = hashlib.md5(config_str.encode()).hexdigest()
        except Exception as e:
            self.logger.error(f"Error updating config hash: {str(e)}")
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value by key"""
        try:
            config_item = self.config_items.get(key)
            if config_item:
                return config_item.value
            return default
        except Exception as e:
            self.logger.error(f"Error getting config value for key '{key}': {str(e)}")
            return default
    
    def set(self, key: str, value: Any, source: ConfigSource = ConfigSource.RUNTIME, is_secret: bool = False, description: str = "") -> bool:
        """Set configuration value"""
        try:
            old_value = self.get(key)
            
            self.config_items[key] = ConfigItem(
                key=key,
                value=value,
                source=source,
                is_secret=is_secret,
                description=description or f"Runtime configuration for {key}"
            )
            
            # Trigger watchers
            self._trigger_watchers(key, old_value, value)
            
            # Update hash
            self._update_config_hash()
            
            self.logger.info(f"Configuration updated: {key} = {'[REDACTED]' if is_secret else value}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error setting config value for key '{key}': {str(e)}")
            return False
    
    def get_dict(self, prefix: str = "") -> Dict[str, Any]:
        """Get configuration as dictionary, optionally filtered by prefix"""
        try:
            result = {}
            for key, config_item in self.config_items.items():
                if not prefix or key.startswith(prefix):
                    # Remove prefix if specified
                    display_key = key[len(prefix):].lstrip('.') if prefix else key
                    result[display_key] = config_item.value
            return result
        except Exception as e:
            self.logger.error(f"Error getting config dict with prefix '{prefix}': {str(e)}")
            return {}
    
    def get_nested_dict(self, prefix: str = "") -> Dict[str, Any]:
        """Get configuration as nested dictionary"""
        try:
            flat_dict = self.get_dict(prefix)
            return self._unflatten_dict(flat_dict)
        except Exception as e:
            self.logger.error(f"Error getting nested config dict with prefix '{prefix}': {str(e)}")
            return {}
    
    def _unflatten_dict(self, flat_dict: Dict[str, Any], sep: str = '.') -> Dict[str, Any]:
        """Convert flat dictionary to nested dictionary"""
        result = {}
        for key, value in flat_dict.items():
            keys = key.split(sep)
            d = result
            for k in keys[:-1]:
                if k not in d:
                    d[k] = {}
                d = d[k]
            d[keys[-1]] = value
        return result
    
    def watch(self, key: str, callback: callable) -> bool:
        """Watch for changes to a configuration key"""
        try:
            if key not in self.watchers:
                self.watchers[key] = []
            self.watchers[key].append(callback)
            self.logger.debug(f"Added watcher for config key: {key}")
            return True
        except Exception as e:
            self.logger.error(f"Error adding watcher for key '{key}': {str(e)}")
            return False
    
    def _trigger_watchers(self, key: str, old_value: Any, new_value: Any):
        """Trigger watchers for a configuration key"""
        try:
            if key in self.watchers:
                for callback in self.watchers[key]:
                    try:
                        callback(key, old_value, new_value)
                    except Exception as e:
                        self.logger.error(f"Error in config watcher callback for '{key}': {str(e)}")
        except Exception as e:
            self.logger.error(f"Error triggering watchers for key '{key}': {str(e)}")
    
    def reload(self) -> bool:
        """Reload configuration from all sources"""
        try:
            old_hash = self._config_hash
            
            # Clear runtime configurations but keep others
            self.config_items = {k: v for k, v in self.config_items.items() if v.source != ConfigSource.RUNTIME}
            
            # Reload all sources
            self._load_default_config()
            self._load_environment_config()
            self._load_file_config()
            self._load_vault_config()
            
            # Update hash
            self._update_config_hash()
            
            if old_hash != self._config_hash:
                self.logger.info("Configuration reloaded successfully - changes detected")
            else:
                self.logger.info("Configuration reloaded successfully - no changes")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error reloading configuration: {str(e)}")
            return False
    
    def validate(self) -> Dict[str, List[str]]:
        """Validate configuration and return any errors"""
        errors = {}
        
        try:
            # Required configuration checks
            required_keys = [
                "api.host",
                "api.port",
                "database.host",
                "database.port",
                "logging.level"
            ]
            
            for key in required_keys:
                if key not in self.config_items:
                    if "missing" not in errors:
                        errors["missing"] = []
                    errors["missing"].append(f"Required configuration key missing: {key}")
            
            # Type validation
            type_checks = {
                "api.port": int,
                "api.workers": int,
                "database.port": int,
                "database.pool_size": int,
                "echo.max_response_length": int,
                "echo.conversation_timeout": int,
                "security.require_auth": bool,
                "voice.enabled": bool
            }
            
            for key, expected_type in type_checks.items():
                if key in self.config_items:
                    value = self.config_items[key].value
                    if not isinstance(value, expected_type):
                        if "type_errors" not in errors:
                            errors["type_errors"] = []
                        errors["type_errors"].append(f"Configuration key '{key}' should be {expected_type.__name__}, got {type(value).__name__}")
            
            # Range validation
            range_checks = {
                "api.port": (1, 65535),
                "api.workers": (1, 32),
                "database.port": (1, 65535),
                "database.pool_size": (1, 100),
                "echo.max_response_length": (100, 10000),
                "echo.conversation_timeout": (60, 86400)
            }
            
            for key, (min_val, max_val) in range_checks.items():
                if key in self.config_items:
                    value = self.config_items[key].value
                    if isinstance(value, (int, float)) and not (min_val <= value <= max_val):
                        if "range_errors" not in errors:
                            errors["range_errors"] = []
                        errors["range_errors"].append(f"Configuration key '{key}' value {value} not in range [{min_val}, {max_val}]")
            
        except Exception as e:
            if "validation_errors" not in errors:
                errors["validation_errors"] = []
            errors["validation_errors"].append(f"Configuration validation error: {str(e)}")
        
        return errors
    
    def export_config(self, include_secrets: bool = False, format: str = "yaml") -> str:
        """Export configuration to string"""
        try:
            config_dict = {}
            for key, config_item in self.config_items.items():
                if config_item.is_secret and not include_secrets:
                    continue
                config_dict[key] = config_item.value
            
            nested_dict = self._unflatten_dict(config_dict)
            
            if format.lower() == "yaml":
                return yaml.dump(nested_dict, default_flow_style=False, sort_keys=True)
            elif format.lower() == "json":
                return json.dumps(nested_dict, indent=2, sort_keys=True)
            else:
                raise ValueError(f"Unsupported export format: {format}")
                
        except Exception as e:
            self.logger.error(f"Error exporting configuration: {str(e)}")
            return ""
    
    def get_stats(self) -> Dict[str, Any]:
        """Get configuration statistics"""
        try:
            source_counts = {}
            secret_count = 0
            
            for config_item in self.config_items.values():
                source = config_item.source.value
                source_counts[source] = source_counts.get(source, 0) + 1
                if config_item.is_secret:
                    secret_count += 1
            
            return {
                "total_items": len(self.config_items),
                "source_distribution": source_counts,
                "secret_items": secret_count,
                "config_hash": self._config_hash,
                "config_file_path": self.config_file_path,
                "watchers_count": sum(len(callbacks) for callbacks in self.watchers.values()),
                "watched_keys": list(self.watchers.keys())
            }
            
        except Exception as e:
            self.logger.error(f"Error getting config stats: {str(e)}")
            return {}

# Singleton instance
_config_manager_instance = None

def get_config_manager(config_file_path: Optional[str] = None) -> ConfigurationManager:
    """Get singleton ConfigurationManager instance"""
    global _config_manager_instance
    if _config_manager_instance is None:
        _config_manager_instance = ConfigurationManager(config_file_path)
    return _config_manager_instance
