name: Echo CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  release:
    types: [ published ]

env:
  ECHO_TOWER_URL: https://***REMOVED***
  PYTHON_VERSION: '3.12'

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      target-env: ${{ steps.check.outputs.target-env }}
    steps:
      - name: Determine deployment strategy
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "target-env=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "target-env=production" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "target-env=none" >> $GITHUB_OUTPUT
          fi

  notify-start:
    runs-on: ubuntu-latest
    steps:
      - name: Notify Echo of pipeline start
        run: |
          curl -k -X POST "${{ env.ECHO_TOWER_URL }}/api/pipelines/trigger"             -H "Content-Type: application/json"             -d '{
              "app_name": "${{ github.event.repository.name }}",
              "git_repo": "${{ github.event.repository.clone_url }}",
              "git_branch": "${{ github.ref_name }}",
              "git_commit": "${{ github.sha }}",
              "trigger_type": "github_actions",
              "target_environments": ["${{ needs.setup.outputs.target-env }}"],
              "run_tests": true,
              "deploy_on_success": ${{ needs.setup.outputs.should-deploy }},
              "notify_on_completion": true
            }' || echo "Failed to notify Echo - continuing with GitHub Actions"
    needs: setup

  lint-and-security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black isort bandit safety
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
      
      - name: Code formatting check (Black)
        run: black --check --diff .
        continue-on-error: true
      
      - name: Import sorting check (isort)
        run: isort --check-only --diff .
        continue-on-error: true
      
      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Security scan with Bandit
        run: |
          bandit -r . -f json -o bandit-report.json || true
          bandit -r . -f txt
        continue-on-error: true
      
      - name: Dependency vulnerability scan
        run: |
          safety check --json --output safety-report.json || true
          safety check
        continue-on-error: true
      
      - name: Upload security reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
        if: always()

  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov pytest-asyncio pytest-mock coverage
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
      
      - name: Generate tests with Echo (if available)
        run: |
          # Try to trigger Echo test generation
          curl -k -X POST "${{ env.ECHO_TOWER_URL }}/api/generate-tests"             -H "Content-Type: application/json"             -d '{
              "file_path": "./",
              "module_name": "${{ github.event.repository.name }}",
              "board_decision_id": "github-actions-${{ github.run_id }}"
            }' || echo "Echo test generation not available - using existing tests"
      
      - name: Run existing tests
        run: |
          if [ -d "tests" ]; then
            pytest tests/ -v --cov=. --cov-report=xml --cov-report=html
          else
            echo "No tests directory found - creating basic smoke test"
            mkdir -p tests
            cat > tests/test_basic.py << EOL
          import sys
          import os
          
          def test_python_version():
              assert sys.version_info >= (3, 10)
          
          def test_imports():
              # Test that main modules can be imported
              try:
                  import json
                  import asyncio
                  assert True
              except ImportError:
                  assert False, "Basic imports failed"
          EOL
            pytest tests/test_basic.py -v
          fi
      
      - name: Upload coverage reports
        uses: actions/upload-artifact@v3
        with:
          name: coverage-reports-py${{ matrix.python-version }}
          path: |
            htmlcov/
            coverage.xml
        if: always()

  build:
    runs-on: ubuntu-latest
    needs: [lint-and-security, test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel setuptools
      
      - name: Create build info
        run: |
          mkdir -p build
          cat > build/build-info.json << EOL
          {
            "build_id": "${{ github.run_id }}",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "repository": "${{ github.repository }}",
            "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "python_version": "${{ env.PYTHON_VERSION }}",
            "event_type": "${{ github.event_name }}"
          }
          EOL
      
      - name: Package application
        run: |
          # Create simple package structure
          mkdir -p dist
          tar -czf dist/${{ github.event.repository.name }}-${{ github.sha }}.tar.gz             --exclude='.git'             --exclude='dist'             --exclude='__pycache__'             --exclude='*.pyc'             .
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: |
            dist/
            build/
          retention-days: 30

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.target-env == 'staging'
    environment: staging
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-artifacts
      
      - name: Deploy to Echo Tower (Staging)
        run: |
          echo "Deploying to Echo Tower staging environment"
          
          # Extract build info
          BUILD_INFO=$(cat build/build-info.json)
          echo "Build info: $BUILD_INFO"
          
          # Trigger deployment via Echo API
          DEPLOY_RESPONSE=$(curl -k -X POST "${{ env.ECHO_TOWER_URL }}/api/deploy"             -H "Content-Type: application/json"             -d '{
              "app_name": "${{ github.event.repository.name }}",
              "version": "${{ github.sha }}",
              "git_commit": "${{ github.sha }}",
              "source_path": "/tmp/github-deploy-${{ github.run_id }}",
              "target_env": "staging",
              "port": 8310,
              "health_check_url": "http://localhost:8310/api/health",
              "dependencies": [],
              "environment_vars": {
                "GITHUB_RUN_ID": "${{ github.run_id }}",
                "GITHUB_SHA": "${{ github.sha }}",
                "GITHUB_REF": "${{ github.ref }}",
                "DEPLOY_ENV": "staging"
              }
            }')
          
          echo "Deployment response: $DEPLOY_RESPONSE"
          
          # Extract deployment ID
          DEPLOYMENT_ID=$(echo $DEPLOY_RESPONSE | jq -r '.deployment_id // "unknown"')
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
      
      - name: Wait for deployment completion
        run: |
          DEPLOYMENT_ID=${{ steps.deploy.outputs.deployment_id }}
          if [ "$DEPLOYMENT_ID" != "unknown" ]; then
            echo "Monitoring deployment $DEPLOYMENT_ID"
            
            for i in {1..20}; do
              STATUS=$(curl -k -s "${{ env.ECHO_TOWER_URL }}/api/deployments/$DEPLOYMENT_ID" | jq -r '.status // "unknown"')
              echo "Deployment status: $STATUS"
              
              if [ "$STATUS" = "active" ]; then
                echo "Deployment successful!"
                exit 0
              elif [ "$STATUS" = "failed" ] || [ "$STATUS" = "rolled_back" ]; then
                echo "Deployment failed with status: $STATUS"
                exit 1
              fi
              
              sleep 30
            done
            
            echo "Deployment timeout - status unknown"
            exit 1
          else
            echo "No deployment ID received - skipping monitoring"
          fi

  deploy-production:
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.target-env == 'production'
    environment: production
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-artifacts
      
      - name: Deploy to Echo Tower (Production)
        run: |
          echo "Deploying to Echo Tower production environment"
          
          # Trigger production deployment
          DEPLOY_RESPONSE=$(curl -k -X POST "${{ env.ECHO_TOWER_URL }}/api/deploy"             -H "Content-Type: application/json"             -d '{
              "app_name": "${{ github.event.repository.name }}",
              "version": "${{ github.sha }}",
              "git_commit": "${{ github.sha }}",
              "source_path": "/tmp/github-deploy-${{ github.run_id }}",
              "target_env": "production",
              "port": 8309,
              "health_check_url": "http://localhost:8309/api/health",
              "dependencies": [],
              "environment_vars": {
                "GITHUB_RUN_ID": "${{ github.run_id }}",
                "GITHUB_SHA": "${{ github.sha }}",
                "GITHUB_REF": "${{ github.ref }}",
                "DEPLOY_ENV": "production"
              }
            }')
          
          echo "Production deployment response: $DEPLOY_RESPONSE"

  integration-tests:
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: needs.setup.outputs.target-env == 'staging'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run integration tests against staging
        run: |
          echo "Running integration tests against staging environment"
          
          # Basic health check
          curl -k -f "${{ env.ECHO_TOWER_URL }}/api/health" || {
            echo "Health check failed"
            exit 1
          }
          
          # Application-specific integration tests
          if [ -f "tests/integration_test.sh" ]; then
            chmod +x tests/integration_test.sh
            STAGING_URL="${{ env.ECHO_TOWER_URL }}" ./tests/integration_test.sh
          else
            echo "No integration tests found - creating basic test"
            curl -k -f "${{ env.ECHO_TOWER_URL }}/api/" || echo "API endpoint test completed"
          fi

  notify-completion:
    runs-on: ubuntu-latest
    needs: [setup, test, build, deploy-staging, deploy-production, integration-tests]
    if: always()
    
    steps:
      - name: Determine overall status
        id: status
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "status=cancelled" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi
      
      - name: Notify Echo of completion
        run: |
          curl -k -X POST "${{ env.ECHO_TOWER_URL }}/api/notifications"             -H "Content-Type: application/json"             -d '{
              "recipient": "patrick.vestal.digital@gmail.com",
              "subject": "GitHub Actions ${{ steps.status.outputs.status }}: ${{ github.repository }}",
              "body": "GitHub Actions pipeline completed with status: ${{ steps.status.outputs.status }}\n\nRepository: ${{ github.repository }}\nCommit: ${{ github.sha }}\nBranch: ${{ github.ref_name }}\nRun ID: ${{ github.run_id }}\nEvent: ${{ github.event_name }}",
              "type": "email"
            }' || echo "Notification failed - continuing"
      
      - name: Update commit status
        if: github.event_name == 'push'
        run: |
          # Update GitHub commit status
          STATUS="${{ steps.status.outputs.status }}"
          if [ "$STATUS" = "success" ]; then
            STATE="success"
            DESCRIPTION="GitHub Actions pipeline completed successfully"
          else
            STATE="failure"
            DESCRIPTION="GitHub Actions pipeline failed"
          fi
          
          curl -X POST             -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}"             -H "Accept: application/vnd.github.v3+json"             "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}"             -d "{
              \"state\": \"$STATE\",
              \"description\": \"$DESCRIPTION\",
              \"context\": \"github-actions/echo-ci\"
            }"

  cleanup:
    runs-on: ubuntu-latest
    needs: [notify-completion]
    if: always()
    
    steps:
      - name: Cleanup temporary resources
        run: |
          echo "Cleaning up temporary resources from run ${{ github.run_id }}"
          # In a real scenario, this would clean up any temporary deployments,
          # test databases, or other resources created during the pipeline
          echo "Cleanup completed"
