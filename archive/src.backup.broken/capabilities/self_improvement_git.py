"""
Enhanced Self-Improvement Module with Git Auto-Commit
Automatically commits improvements to Git repository
"""

import ast
import git
import subprocess
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
import logging
from datetime import datetime
import hashlib
import asyncpg

logger = logging.getLogger(__name__)

class GitEnabledSelfImprovement:
    """Self-improvement system with automatic Git commits"""

    def __init__(self, repo_path: str = "/opt/tower-echo-brain"):
        self.repo_path = Path(repo_path)
        try:
            self.repo = git.Repo(self.repo_path)
        except git.InvalidGitRepositoryError:
            # Initialize git repo if it doesn't exist
            self.repo = git.Repo.init(self.repo_path)
            logger.info(f"Initialized git repository at {self.repo_path}")

        self.improvement_history = []
        self.db_config = {
            'host': 'localhost',
            'database': 'echo_brain',
            'user': 'patrick',
            'password': '***REMOVED***'
        }

    async def apply_improvement_with_commit(
        self,
        file_path: str,
        improvement_type: str,
        description: str,
        changes: str
    ) -> Dict[str, Any]:
        """
        Apply an improvement and automatically commit it

        Args:
            file_path: Path to file to improve
            improvement_type: Type of improvement (docstring, optimization, etc)
            description: Description of the improvement
            changes: The actual code changes to apply

        Returns:
            Result with commit details
        """

        file_path = Path(file_path)
        if not file_path.exists():
            return {
                "success": False,
                "error": "File not found"
            }

        # Create feature branch
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        branch_name = f"self-improvement-{timestamp}"

        try:
            # Store original content
            original_content = file_path.read_text()

            # Checkout new branch
            current_branch = self.repo.active_branch
            new_branch = self.repo.create_head(branch_name)
            new_branch.checkout()

            # Apply the changes
            file_path.write_text(changes)

            # Run tests to verify improvement
            test_result = await self._run_tests(file_path)

            if test_result['success']:
                # Commit the changes
                self.repo.index.add([str(file_path)])
                commit_message = f"""ü§ñ Auto-improvement: {improvement_type} for {file_path.name}

Type: {improvement_type}
Description: {description}
File: {file_path}
Tests: ‚úÖ Passed

Generated by Echo Brain Autonomous System
"""
                commit = self.repo.index.commit(commit_message)

                # Merge to main branch
                current_branch.checkout()
                self.repo.git.merge(branch_name)

                # Delete feature branch
                self.repo.delete_head(branch_name, force=True)

                # Store in database
                await self._store_improvement_history(
                    file_path=str(file_path),
                    improvement_type=improvement_type,
                    commit_hash=commit.hexsha,
                    success=True
                )

                return {
                    "success": True,
                    "commit_hash": commit.hexsha,
                    "branch": branch_name,
                    "message": commit_message,
                    "tests_passed": True
                }

            else:
                # Tests failed, rollback
                file_path.write_text(original_content)
                current_branch.checkout()
                self.repo.delete_head(branch_name, force=True)

                await self._store_improvement_history(
                    file_path=str(file_path),
                    improvement_type=improvement_type,
                    commit_hash=None,
                    success=False,
                    error=test_result.get('error', 'Tests failed')
                )

                return {
                    "success": False,
                    "error": f"Tests failed: {test_result.get('error')}",
                    "rollback": True
                }

        except Exception as e:
            logger.error(f"Failed to apply improvement: {e}")
            # Ensure we're back on original branch
            try:
                current_branch.checkout()
                if branch_name in [b.name for b in self.repo.branches]:
                    self.repo.delete_head(branch_name, force=True)
            except:
                pass

            return {
                "success": False,
                "error": str(e)
            }

    async def _run_tests(self, file_path: Path) -> Dict[str, Any]:
        """Run tests to verify improvement works"""

        # Simple syntax check
        try:
            if file_path.suffix == '.py':
                # Check Python syntax
                compile(file_path.read_text(), str(file_path), 'exec')

                # Run actual test if exists
                test_file = self.repo_path / "tests" / f"test_{file_path.stem}.py"
                if test_file.exists():
                    result = subprocess.run(
                        ["/opt/tower-echo-brain/venv/bin/python", "-m", "pytest", str(test_file), "-v"],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )

                    return {
                        "success": result.returncode == 0,
                        "output": result.stdout,
                        "error": result.stderr if result.returncode != 0 else None
                    }

            return {"success": True, "output": "Syntax check passed"}

        except SyntaxError as e:
            return {
                "success": False,
                "error": f"Syntax error: {e}"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    async def _store_improvement_history(
        self,
        file_path: str,
        improvement_type: str,
        commit_hash: Optional[str],
        success: bool,
        error: Optional[str] = None
    ):
        """Store improvement history in PostgreSQL"""

        try:
            conn = await asyncpg.connect(**self.db_config)

            # Create table if not exists
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS self_improvement_history (
                    id SERIAL PRIMARY KEY,
                    file_path TEXT,
                    improvement_type VARCHAR(100),
                    commit_hash VARCHAR(40),
                    success BOOLEAN,
                    error TEXT,
                    created_at TIMESTAMP DEFAULT NOW()
                )
            """)

            # Insert record
            await conn.execute("""
                INSERT INTO self_improvement_history
                (file_path, improvement_type, commit_hash, success, error)
                VALUES ($1, $2, $3, $4, $5)
            """, file_path, improvement_type, commit_hash, success, error)

            await conn.close()

        except Exception as e:
            logger.error(f"Failed to store improvement history: {e}")

    async def demonstrate_auto_improvement(self) -> Dict[str, Any]:
        """
        Demonstrate auto-improvement on model_router.py
        """

        model_router_path = self.repo_path / "src" / "model_router.py"

        if not model_router_path.exists():
            # Create a sample file to improve
            model_router_path.parent.mkdir(parents=True, exist_ok=True)
            model_router_path.write_text("""
class ModelRouter:
    def __init__(self):
        self.models = {}
        self.complexity = 0

    def calculate_complexity(self, text):
        # TODO: Add docstring
        words = text.split()
        complexity = len(words) * 0.1
        if len(words) > 100:
            complexity *= 1.5
        if len(words) > 500:
            complexity *= 2
        return complexity

    def select_model(self, query):
        # TODO: Add docstring
        complexity = self.calculate_complexity(query)
        if complexity < 10:
            return "simple_model"
        elif complexity < 50:
            return "medium_model"
        else:
            return "complex_model"
""")

        # Improve by adding docstrings
        improved_code = """
class ModelRouter:
    \"\"\"Routes queries to appropriate models based on complexity\"\"\"

    def __init__(self):
        \"\"\"Initialize the ModelRouter with empty model registry\"\"\"
        self.models = {}
        self.complexity = 0
        logger.info("ModelRouter initialized")

    def calculate_complexity(self, text: str) -> float:
        \"\"\"
        Calculate the complexity score of input text.

        Args:
            text: The input text to analyze

        Returns:
            float: Complexity score based on word count and thresholds
        \"\"\"
        logger.info(f"Calculating complexity for text of length {len(text)}")
        words = text.split()
        complexity = len(words) * 0.1
        if len(words) > 100:
            complexity *= 1.5
        if len(words) > 500:
            complexity *= 2
        return complexity

    def select_model(self, query: str) -> str:
        \"\"\"
        Select the appropriate model based on query complexity.

        Args:
            query: The input query to route

        Returns:
            str: Name of the selected model
        \"\"\"
        logger.info("Selecting model for query")
        complexity = self.calculate_complexity(query)
        if complexity < 10:
            return "simple_model"
        elif complexity < 50:
            return "medium_model"
        else:
            return "complex_model"

# Add import for logging
import logging
logger = logging.getLogger(__name__)
"""

        # Apply the improvement
        result = await self.apply_improvement_with_commit(
            file_path=str(model_router_path),
            improvement_type="add_docstrings_and_logging",
            description="Added comprehensive docstrings and logging to all methods",
            changes=improved_code
        )

        return result

    def get_commit_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent commit history"""

        commits = []
        for commit in list(self.repo.iter_commits())[:limit]:
            if "Auto-improvement" in commit.message:
                commits.append({
                    "hash": commit.hexsha[:8],
                    "message": commit.message.split('\n')[0],
                    "author": str(commit.author),
                    "date": datetime.fromtimestamp(commit.committed_date).isoformat(),
                    "files": list(commit.stats.files.keys())
                })

        return commits


# Test function
async def test_git_auto_commit():
    """Test the Git auto-commit functionality"""

    print("=" * 60)
    print("TESTING GIT AUTO-COMMIT FOR SELF-IMPROVEMENT")
    print("=" * 60)

    improver = GitEnabledSelfImprovement()

    # Demonstrate auto-improvement
    print("\n1. Applying improvement to model_router.py...")
    result = await improver.demonstrate_auto_improvement()

    if result['success']:
        print(f"‚úÖ SUCCESS! Committed with hash: {result['commit_hash']}")
        print(f"   Branch: {result['branch']}")
        print(f"   Tests: {'‚úÖ Passed' if result['tests_passed'] else '‚ùå Failed'}")
        print("\n   Commit message:")
        print(result['message'])
    else:
        print(f"‚ùå FAILED: {result.get('error')}")

    # Show commit history
    print("\n2. Recent auto-improvement commits:")
    commits = improver.get_commit_history(5)

    for commit in commits:
        print(f"   - {commit['hash']}: {commit['message']}")
        print(f"     Date: {commit['date']}")
        print(f"     Files: {', '.join(commit['files'])}")

    print("\n" + "=" * 60)
    print("GIT AUTO-COMMIT TEST COMPLETE")
    print("=" * 60)

    return result['success'] if result else False


if __name__ == "__main__":
    import asyncio
    asyncio.run(test_git_auto_commit())